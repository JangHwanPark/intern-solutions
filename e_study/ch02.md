## 시간 복잡도
<hr/>

- 알고리즘의 실행 시간이 입력 크기에 따라 어떻게 변하는지를 수학적으로 표현
- 가장 일반적인 표기법인 빅오(Big O) 표기법을 사용
- 빅오 표기법은 최악의 경우의 실행 시간을 나타내며, 알고리즘의 성능을 비교하고 예측하는 데 유용

![BigO](./image/time.png)

> O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^N) < O(N!)

<br>

### 데이터가 늘어날 때 단계 수가 어떻게 증가하는가를 의미

> O(3) == O(100) == O(1)
> O(3N) == O(N) == O(100N) == O(N)

- 빅 오는 입력값 n이 증가할때 알고리즘의 시간과, 성능이 어떻게 바뀌는지 설명한다.

### O(1)과 O(N)에서 데이터 변화가 미치는 영향

- O(1) 알고리즘은 데이터 증가 또는 감소에 영향을 받지 않는다.
- O(N) 알고리즘은 데이터 증가가 성능에 영향을 미친다.

<br>

## 배열
<hr/>

- 같은 타입의 데이터를 메모리 상에 연속적으로 저장하는 자료구조
- O(1)에 특정 인덱스의 요소에 접근, 변경 가능
- 오버헤드가 적음
- 메모리 상에 연속한 구간을 잡아야해서 할당에 제약이 있음

### 임의의 위치에 있는 요소 접근 및 변경 (O(1))
![access](./image/array/arr01.png)

### 요소를 끝에 추가 (O(1))
![push](./image/array/arr02.png)

### 마지막 요소를 제거 (O(1))
![pop](./image/array/arr03.png)

### k번째 위치에 요소를 추가 (O(n))
![insert](./image/array/arr04.png)

### k번째 위치에 요소를 제거 (O(n))
![remove](./image/array/arr05.png)

<br>

## 과제 요구사항
<hr/>

1. 배열의 access, push, pop, insert, remove 기능을 구현. 
2. 시간복잡도를 고려하여 구현할것. 
3. 배열의 크기는 정적으로 할당되어야 함. (배열의 크기는 100)
4. 구현 언어는 상관없으나 언어에서 제공하는 내장함수 사용 불가. 
5. 구현한 코드는 PR로 제출.